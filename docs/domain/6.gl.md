Finance/Accounting Domain Model
Entity: Account
# Finance/Accounting Domain Model

## Entity: Account

```ts
Account {
  accountId: UUID
  accountCode: string // e.g., "1000", "4100"
  accountName: string // e.g., "Cash/Bank Account"
  accountType: enum [Asset, Liability, Revenue, Expense]
  normalBalance: enum [Debit, Credit]
  currentBalance: decimal // Real-time balance
  isActive: boolean
  isSystemAccount: boolean // Cannot be deleted

  createdAt: timestamp
  createdBy: UUID
}
```

## Entity: JournalEntry

```ts
JournalEntry {
  entryId: UUID
  entryNumber: string // Auto-generated: "JE-2025-00001"
  entryDate: date // When entry was created
  transactionDate: date // When transaction occurred
  reference: string // e.g., "Member Registration - MEM-001"
  description: string?
  status: enum [Posted] // Always posted (auto-post)

  // Source tracking
  sourceModule: enum [Membership, Wallet, Claims, Contributions, Manual]
  sourceEntityId: UUID? // memberId, claimId, etc.
  sourceTransactionType: string // e.g., "RegistrationApproval", "WalletDeposit"

  // Total amounts (for quick validation)
  totalDebit: decimal
  totalCredit: decimal

  // Audit
  createdAt: timestamp
  createdBy: UUID
  postedAt: timestamp
  postedBy: UUID
}
```

## Entity: JournalEntryLine

```ts
JournalEntryLine {
  lineId: UUID
  entryId: UUID // Parent journal entry
  lineNumber: int // Order within entry (1, 2, 3...)

  accountId: UUID
  accountCode: string // Denormalized for quick reference
  accountName: string // Denormalized

  debit: decimal? // null if credit
  credit: decimal? // null if debit
  description: string?
}
```

## Initial Chart of Accounts Setup

Seed Data:

```js
const CHART_OF_ACCOUNTS = [
  // Assets (1xxx)
  {
    accountCode: "1000",
    accountName: "Cash/Bank Account",
    accountType: "Asset",
    normalBalance: "Debit",
    isSystemAccount: true
  },

  // Liabilities (2xxx)
  {
    accountCode: "2100",
    accountName: "Member Prepaid Wallet Liability",
    accountType: "Liability",
    normalBalance: "Credit",
    isSystemAccount: true
  },

  // Revenue (4xxx)
  {
    accountCode: "4100",
    accountName: "Registration Fee Revenue",
    accountType: "Revenue",
    normalBalance: "Credit",
    isSystemAccount: true
  },
  {
    accountCode: "4200",
    accountName: "Member Contribution Income",
    accountType: "Revenue",
    normalBalance: "Credit",
    isSystemAccount: true
  },

  // Expenses (5xxx)
  {
    accountCode: "5100",
    accountName: "Death Benefit Payout Expense",
    accountType: "Expense",
    normalBalance: "Debit",
    isSystemAccount: true
  },
  {
    accountCode: "5200",
    accountName: "Operational Expense",
    accountType: "Expense",
    normalBalance: "Debit",
    isSystemAccount: true
  }
];
```

## GL Service - Core Operations

### 1. CreateJournalEntry

```ts
async function createJournalEntry(input, trx) {
  // Input structure:
  // {
  //   entries: [
  //     { accountCode: "1000", debit: 1000, description: "..." },
  //     { accountCode: "2100", credit: 500 },
  //     { accountCode: "4100", credit: 500 }
  //   ],
  //   reference: "Member Registration - MEM-001",
  //   transactionDate: Date,
  //   sourceModule: "Membership",
  //   sourceEntityId: "member-uuid",
  //   sourceTransactionType: "RegistrationApproval",
  //   createdBy: "user-uuid"
  // }

  // 1. Validate balanced entry
  const totalDebit = input.entries
    .filter(e => e.debit)
    .reduce((sum, e) => sum + e.debit, 0);

  const totalCredit = input.entries
    .filter(e => e.credit)
    .reduce((sum, e) => sum + e.credit, 0);

  if (Math.abs(totalDebit - totalCredit) > 0.01) { // Allow 1 cent rounding
    throw new Error(`Entry not balanced: Debit ${totalDebit} != Credit ${totalCredit}`);
  }

  // 2. Check for duplicate entry (idempotency)
  if (input.sourceEntityId && input.sourceTransactionType) {
    const existing = await db.journalEntries.findOne({
      where: {
        sourceEntityId: input.sourceEntityId,
        sourceTransactionType: input.sourceTransactionType
      }
    }, { transaction: trx });

    if (existing) {
      console.log('Duplicate entry detected, returning existing:', existing.entryId);
      return existing; // Idempotent
    }
  }

  // 3. Get accounts and validate
  const accountCodes = input.entries.map(e => e.accountCode);
  const accounts = await db.accounts.findAll({
    where: { accountCode: { in: accountCodes }, isActive: true }
  }, { transaction: trx });

  if (accounts.length !== accountCodes.length) {
    throw new Error('One or more accounts not found or inactive');
  }

  const accountMap = new Map(accounts.map(a => [a.accountCode, a]));

  // 4. Generate entry number
  const entryNumber = await generateEntryNumber(input.transactionDate);

  // 5. Create journal entry header
  const entry = await db.journalEntries.create({
    entryId: generateUUID(),
    entryNumber,
    entryDate: new Date(),
    transactionDate: input.transactionDate,
    reference: input.reference,
    description: input.description,
    status: 'Posted', // Auto-post
    sourceModule: input.sourceModule,
    sourceEntityId: input.sourceEntityId,
    sourceTransactionType: input.sourceTransactionType,
    totalDebit,
    totalCredit,
    createdAt: new Date(),
    createdBy: input.createdBy,
    postedAt: new Date(),
    postedBy: input.createdBy
  }, { transaction: trx });

  // 6. Create journal entry lines
  for (let i = 0; i < input.entries.length; i++) {
    const lineInput = input.entries[i];
    const account = accountMap.get(lineInput.accountCode);

    await db.journalEntryLines.create({
      lineId: generateUUID(),
      entryId: entry.entryId,
      lineNumber: i + 1,
      accountId: account.accountId,
      accountCode: account.accountCode,
      accountName: account.accountName,
      debit: lineInput.debit || null,
      credit: lineInput.credit || null,
      description: lineInput.description
    }, { transaction: trx });
  }

  // 7. Update account balances
  for (const lineInput of input.entries) {
    const account = accountMap.get(lineInput.accountCode);

    let balanceChange = 0;

    // Calculate balance change based on normal balance
    if (account.normalBalance === 'Debit') {
      balanceChange = (lineInput.debit || 0) - (lineInput.credit || 0);
    } else {
      balanceChange = (lineInput.credit || 0) - (lineInput.debit || 0);
    }

    await db.accounts.increment('currentBalance', {
      by: balanceChange,
      where: { accountId: account.accountId }
    }, { transaction: trx });
  }

  return entry;
}
```

### 2. ReverseJournalEntry

```ts
async function reverseJournalEntry(originalEntryId, reason, userId, trx) {
  // 1. Get original entry with lines
  const original = await db.journalEntries.findByPk(originalEntryId, {
    include: [{ model: db.journalEntryLines, as: 'lines' }]
  }, { transaction: trx });

  if (!original) {
    throw new Error('Original entry not found');
  }

  // 2. Create reversing entries (swap debit/credit)
  const reversingEntries = original.lines.map(line => ({
    accountCode: line.accountCode,
    debit: line.credit || null,
    credit: line.debit || null,
    description: `Reversal: ${line.description || ''}`
  }));

  // 3. Create reversing entry
  return await createJournalEntry({
    entries: reversingEntries,
    reference: `Reversal of ${original.entryNumber} - ${reason}`,
    transactionDate: new Date(),
    sourceModule: original.sourceModule,
    sourceTransactionType: `${original.sourceTransactionType}_REVERSAL`,
    createdBy: userId
  }, trx);
}
```

### 3. GetAccountBalance

```ts
async function getAccountBalance(accountCode, asOfDate = null) {
  const account = await db.accounts.findOne({
    where: { accountCode }
  });

  if (!account) {
    throw new Error('Account not found');
  }

  // If no date specified, return current balance
  if (!asOfDate) {
    return {
      accountCode: account.accountCode,
      accountName: account.accountName,
      balance: account.currentBalance
    };
  }

  // Calculate historical balance
  const lines = await db.journalEntryLines.findAll({
    include: [{
      model: db.journalEntries,
      as: 'entry',
      where: {
        transactionDate: { lte: asOfDate },
        status: 'Posted'
      }
    }],
    where: { accountCode }
  });

  let balance = 0;
  for (const line of lines) {
    if (account.normalBalance === 'Debit') {
      balance += (line.debit || 0) - (line.credit || 0);
    } else {
      balance += (line.credit || 0) - (line.debit || 0);
    }
  }

  return {
    accountCode: account.accountCode,
    accountName: account.accountName,
    balance,
    asOfDate
  };
}
```

### 4. GenerateTrialBalance

```ts
async function generateTrialBalance(asOfDate = new Date()) {
  const accounts = await db.accounts.findAll({
    where: { isActive: true },
    order: [['accountCode', 'ASC']]
  });

  const balances = [];
  let totalDebits = 0;
  let totalCredits = 0;

  for (const account of accounts) {
    const { balance } = await getAccountBalance(account.accountCode, asOfDate);

    // Convert balance to debit/credit based on normal balance
    let debitBalance = 0;
    let creditBalance = 0;

    if (balance > 0) {
      if (account.normalBalance === 'Debit') {
        debitBalance = balance;
      } else {
        creditBalance = balance;
      }
    } else if (balance < 0) {
      // Negative balance means opposite side
      if (account.normalBalance === 'Debit') {
        creditBalance = Math.abs(balance);
      } else {
        debitBalance = Math.abs(balance);
      }
    }

    totalDebits += debitBalance;
    totalCredits += creditBalance;

    balances.push({
      accountCode: account.accountCode,
      accountName: account.accountName,
      accountType: account.accountType,
      debit: debitBalance || null,
      credit: creditBalance || null
    });
  }

  return {
    asOfDate,
    accounts: balances,
    totalDebits,
    totalCredits,
    balanced: Math.abs(totalDebits - totalCredits) < 0.01
  };
}
```

### 5. GenerateBalanceSheet

```ts
async function generateBalanceSheet(asOfDate = new Date()) {
  const accounts = await db.accounts.findAll({
    where: { isActive: true }
  });

  const assets = [];
  const liabilities = [];
  let totalAssets = 0;
  let totalLiabilities = 0;

  for (const account of accounts) {
    const { balance } = await getAccountBalance(account.accountCode, asOfDate);

    if (account.accountType === 'Asset') {
      assets.push({
        accountCode: account.accountCode,
        accountName: account.accountName,
        balance
      });
      totalAssets += balance;
    } else if (account.accountType === 'Liability') {
      liabilities.push({
        accountCode: account.accountCode,
        accountName: account.accountName,
        balance
      });
      totalLiabilities += balance;
    }
  }

  // Calculate equity (Assets - Liabilities)
  const equity = totalAssets - totalLiabilities;

  return {
    asOfDate,
    assets,
    totalAssets,
    liabilities,
    totalLiabilities,
    equity
  };
}
```

### 6. GenerateIncomeStatement

```ts
async function generateIncomeStatement(startDate, endDate) {
  const accounts = await db.accounts.findAll({
    where: { 
      isActive: true,
      accountType: { in: ['Revenue', 'Expense'] }
    }
  });

  const revenue = [];
  const expenses = [];
  let totalRevenue = 0;
  let totalExpenses = 0;

  for (const account of accounts) {
    // Get activity in date range
    const lines = await db.journalEntryLines.findAll({
      include: [{
        model: db.journalEntries,
        as: 'entry',
        where: {
          transactionDate: { 
            gte: startDate,
            lte: endDate
          },
          status: 'Posted'
        }
      }],
      where: { accountCode: account.accountCode }
    });

    let amount = 0;
    for (const line of lines) {
      if (account.normalBalance === 'Credit') {
        amount += (line.credit || 0) - (line.debit || 0);
      } else {
        amount += (line.debit || 0) - (line.credit || 0);
      }
    }

    if (account.accountType === 'Revenue') {
      revenue.push({
        accountCode: account.accountCode,
        accountName: account.accountName,
        amount
      });
      totalRevenue += amount;
    } else {
      expenses.push({
        accountCode: account.accountCode,
        accountName: account.accountName,
        amount
      });
      totalExpenses += amount;
    }
  }

  const netIncome = totalRevenue - totalExpenses;

  return {
    periodStart: startDate,
    periodEnd: endDate,
    revenue,
    totalRevenue,
    expenses,
    totalExpenses,
    netIncome
  };
}
```

## Example Journal Entries

### Member Registration Approval

```js
await glService.createJournalEntry({
  entries: [
    { 
      accountCode: "1000", // Cash
      debit: 1500, // Registration fee (500) + Advance deposit (1000)
      description: "Cash received for member registration"
    },
    { 
      accountCode: "4100", // Registration Fee Revenue
      credit: 500,
      description: "Registration fee earned"
    },
    { 
      accountCode: "2100", // Member Prepaid Wallet Liability
      credit: 1000,
      description: "Advance deposit held for future contributions"
    }
  ],
  reference: "Member Registration - MEM-2025-00001",
  transactionDate: new Date(),
  sourceModule: "Membership",
  sourceEntityId: memberId,
  sourceTransactionType: "RegistrationApproval",
  createdBy: userId
}, trx);
```

### Wallet Deposit Approval

```js
await glService.createJournalEntry({
  entries: [
    { accountCode: "1000", debit: 500 },
    { accountCode: "2100", credit: 500 }
  ],
  reference: `Wallet Deposit - ${depositRequestId}`,
  transactionDate: depositDate,
  sourceModule: "Wallet",
  sourceEntityId: depositRequestId,
  sourceTransactionType: "WalletDepositApproval",
  createdBy: userId
}, trx);
```

### Death Benefit Payout

```js
await glService.createJournalEntry({
  entries: [
    { accountCode: "5100", debit: 50000 }, // Death Benefit Expense
    { accountCode: "1000", credit: 50000 } // Cash
  ],
  reference: `Death Benefit Payout - Claim ${claimId}`,
  transactionDate: paymentDate,
  sourceModule: "Claims",
  sourceEntityId: claimId,
  sourceTransactionType: "DeathBenefitPayout",
  createdBy: userId
}, trx);
```

### Contribution Collected (from Wallet)

```js
await glService.createJournalEntry({
  entries: [
    { accountCode: "2100", debit: 100 }, // Reduce liability
    { accountCode: "4200", credit: 100 } // Contribution income
  ],
  reference: `Contribution Collected - ${contributionId}`,
  transactionDate: collectionDate,
  sourceModule: "Contributions",
  sourceEntityId: contributionId,
  sourceTransactionType: "ContributionFromWallet",
  createdBy: userId
}, trx);
```

### Contribution Collected (Direct Cash)

```js
await glService.createJournalEntry({
  entries: [
    { accountCode: "1000", debit: 100 }, // Cash collected
    { accountCode: "4200", credit: 100 } // Contribution income
  ],
  reference: `Contribution Collected - ${contributionId}`,
  transactionDate: collectionDate,
  sourceModule: "Contributions",
  sourceEntityId: contributionId,
  sourceTransactionType: "ContributionDirectCash",
  createdBy: userId
}, trx);
```

## Database Schema

```sql
CREATE TABLE accounts (
  account_id UUID PRIMARY KEY,
  account_code VARCHAR(20) UNIQUE NOT NULL,
  account_name VARCHAR(255) NOT NULL,
  account_type VARCHAR(20) NOT NULL, -- Asset, Liability, Revenue, Expense
  normal_balance VARCHAR(10) NOT NULL, -- Debit, Credit
  current_balance DECIMAL(15,2) DEFAULT 0,
  is_active BOOLEAN DEFAULT TRUE,
  is_system_account BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  created_by UUID REFERENCES users(user_id)
);

CREATE TABLE journal_entries (
  entry_id UUID PRIMARY KEY,
  entry_number VARCHAR(50) UNIQUE NOT NULL,
  entry_date DATE NOT NULL,
  transaction_date DATE NOT NULL,
  reference VARCHAR(255) NOT NULL,
  description TEXT,
  status VARCHAR(20) DEFAULT 'Posted',
  source_module VARCHAR(50),
  source_entity_id UUID,
  source_transaction_type VARCHAR(100),
  total_debit DECIMAL(15,2) NOT NULL,
  total_credit DECIMAL(15,2) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  created_by UUID REFERENCES users(user_id),
  posted_at TIMESTAMP,
  posted_by UUID REFERENCES users(user_id),
  
  CONSTRAINT chk_balanced CHECK (ABS(total_debit - total_credit) < 0.01)
);

CREATE TABLE journal_entry_lines (
  line_id UUID PRIMARY KEY,
  entry_id UUID NOT NULL REFERENCES journal_entries(entry_id),
  line_number INT NOT NULL,
  account_id UUID NOT NULL REFERENCES accounts(account_id),
  account_code VARCHAR(20) NOT NULL,
  account_name VARCHAR(255) NOT NULL,
  debit DECIMAL(15,2),
  credit DECIMAL(15,2),
  description TEXT,
  
  CONSTRAINT chk_debit_or_credit CHECK (
    (debit IS NOT NULL AND credit IS NULL) OR 
    (credit IS NOT NULL AND debit IS NULL)
  ),
  CONSTRAINT chk_positive_amounts CHECK (
    (debit IS NULL OR debit >= 0) AND 
    (credit IS NULL OR credit >= 0)
  )
);

-- Indexes
CREATE INDEX idx_accounts_code ON accounts(account_code);
CREATE INDEX idx_accounts_type ON accounts(account_type);
CREATE INDEX idx_je_number ON journal_entries(entry_number);
CREATE INDEX idx_je_date ON journal_entries(transaction_date);
CREATE INDEX idx_je_source ON journal_entries(source_module, source_entity_id);
CREATE INDEX idx_je_source_type ON journal_entries(source_entity_id, source_transaction_type);
CREATE INDEX idx_jel_entry ON journal_entry_lines(entry_id);
CREATE INDEX idx_jel_account ON journal_entry_lines(account_code);
```

## Validation Rules

- Entry must be balanced (debits = credits, ±1 cent tolerance)
- Each line must have either debit OR credit (not both, not neither)
- Amounts must be positive (≥ 0)
- All accounts must exist and be active
- Source tracking (module + entityId + transactionType) for idempotency
- Entry number unique and sequential


## Helper: Generate Entry Number

```ts
async function generateEntryNumber(transactionDate) {
  const year = transactionDate.getFullYear();

  // Get last entry number for this year
  const lastEntry = await db.journalEntries.findOne({
    where: {
      entryNumber: { like: `JE-${year}-%` }
    },
    order: [['entryNumber', 'DESC']]
  });

  let sequence = 1;
  if (lastEntry) {
    const parts = lastEntry.entryNumber.split('-');
    sequence = parseInt(parts[2]) + 1;
  }

  return `JE-${year}-${sequence.toString().padStart(5, '0')}`;
}
```

## Integration Pattern

All financial transactions follow this pattern:

```ts
async function someFinancialOperation(input) {
  return await db.transaction(async (trx) => {
    // 1. Perform business logic
    await updateBusinessEntity(..., trx);

    // 2. Create GL entry
    await glService.createJournalEntry({
      entries: [...],
      reference: "...",
      transactionDate: ...,
      sourceModule: "...",
      sourceEntityId: ...,
      sourceTransactionType: "...",
      createdBy: userId
    }, trx);

    // 3. Both succeed or both fail (atomic)
  });
}
```

## Summary

This Finance/GL design provides:

- Double-entry bookkeeping enforcement
- Auto-posting (immediate consistency)
- Idempotency (duplicate detection)
- Real-time account balances
- Historical balance queries
- Financial reports (Trial Balance, Balance Sheet, Income Statement)
- Audit trail via source tracking
- Reversal entries for corrections
