## Member Wallet Context - Domain Design

### Core Principles

1. **Sub-Ledger**: Member wallets track individual balances (must reconcile with GL account 2100)
2. **Prepaid Balance**: Members can deposit money in advance for future contributions
3. **Approval Workflow**: Deposits require admin approval before crediting wallet
4. **Debit Requests**: For contributions, system creates debit request → agent gets member acknowledgment → wallet debited
5. **GL Integration**: Every wallet transaction creates corresponding GL entry (atomic)
6. **Cannot go negative**: Wallet balance must always be ≥ 0

---

## Domain Model

### Entity: MemberWallet

```javascript
MemberWallet {
  walletId: UUID
  memberId: UUID // One-to-one with Member

  // Balance
  currentBalance: decimal // Current available balance

  // Statistics
  totalDeposited: decimal // Lifetime deposits
  totalDebited: decimal // Lifetime debits

  // Timestamps
  createdAt: timestamp
  updatedAt: timestamp
}
```

---

### Entity: WalletTransaction

```javascript
WalletTransaction {
  transactionId: UUID
  walletId: UUID
  memberId: UUID // Denormalized for queries

  // Transaction Details
  transactionType: enum [Deposit, Debit, Refund, Adjustment]
  amount: decimal
  balanceBefore: decimal
  balanceAfter: decimal

  // Status
  status: enum [Pending, Approved, Rejected, Completed, Cancelled]

  // Source tracking
  sourceModule: enum [Wallet, Contributions, Membership]
  sourceEntityId: UUID? // depositRequestId, contributionId, etc.
  sourceTransactionType: string

  // GL Integration
  journalEntryId: UUID? // Link to GL entry

  // Metadata
  description: string?
  notes: string?

  // Approval (for deposits)
  approvedBy: UUID?
  approvedAt: timestamp?
  rejectionReason: string?

  // Timestamps
  createdAt: timestamp
  createdBy: UUID
}
```

---

### Entity: WalletDepositRequest

```javascript
WalletDepositRequest {
  depositRequestId: UUID
  memberId: UUID
  walletId: UUID

  // Deposit Details
  amount: decimal
  collectionDate: date
  collectionMode: enum [Cash, BankTransfer, Cheque]
  referenceNumber: string? // For bank transfer/cheque

  // Agent who collected
  collectedBy: UUID // AgentId

  // Status
  status: enum [PendingApproval, Approved, Rejected]

  // Approval
  approvedBy: UUID?
  approvedAt: timestamp?
  rejectionReason: string?

  // Links
  walletTransactionId: UUID? // Created when approved
  journalEntryId: UUID? // GL entry

  // Metadata
  notes: string?

  // Timestamps
  createdAt: timestamp
  updatedAt: timestamp
}
```

---

### Entity: WalletDebitRequest

```javascript
WalletDebitRequest {
  debitRequestId: UUID
  memberId: UUID
  walletId: UUID

  // Debit Details
  amount: decimal
  reason: string // e.g., "Contribution for death claim CL-001"

  // Source (contribution cycle)
  contributionCycleId: UUID
  memberContributionId: UUID

  // Status
  status: enum [PendingAcknowledgment, Acknowledged, Completed, Invalidated, Cancelled]

  // Acknowledgment (agent confirms with member)
  acknowledgedBy: UUID? // AgentId
  acknowledgedAt: timestamp?

  // Completion
  walletTransactionId: UUID? // Created when debited
  journalEntryId: UUID? // GL entry

  // Invalidation (if member pays directly)
  invalidatedReason: string?
  invalidatedBy: UUID?
  invalidatedAt: timestamp?

  // Timestamps
  createdAt: timestamp
  updatedAt: timestamp
}
```

---

## Business Rules

### Wallet Creation

- Created automatically when member registration is approved
- Initial balance = advance deposit from registration payment
- One wallet per member (one-to-one)

### Deposits

- Agent collects cash/payment → creates deposit request
- Deposit request requires approval (Unit Admin or configured approver)
- Upon approval: wallet credited + GL entry created (atomic)
- Can only deposit positive amounts

### Debits

- System creates debit request (e.g., when contribution cycle starts)
- Requires member acknowledgment (via agent)
- Upon acknowledgment: wallet debited + GL entry created (atomic)
- Cannot debit if insufficient balance
- Can be invalidated if member pays directly in cash

### Balance Rules

- Balance cannot go negative
- Balance = sum of all completed transactions
- Wallet balance must reconcile with GL account 2100 (Member Prepaid Liability)

---

## Commands

#### 1. CreateMemberWallet (Auto on registration approval)

**Triggered by:** System (when member registration approved)

**Input:**

```json
{
  "memberId": "uuid",
  "initialBalance": 1000, // Advance deposit
  "createdBy": "uuid" // Admin who approved registration
}
```

**Backend Logic:**

```javascript
async function createMemberWallet(input, trx) {
  // 1. Check if wallet already exists
  const existing = await db.memberWallets.findOne(
    {
      where: { memberId: input.memberId },
    },
    { transaction: trx }
  );

  if (existing) {
    throw new Error("Wallet already exists for this member");
  }

  // 2. Create wallet
  const wallet = await db.memberWallets.create(
    {
      walletId: generateUUID(),
      memberId: input.memberId,
      currentBalance: input.initialBalance,
      totalDeposited: input.initialBalance,
      totalDebited: 0,
      createdAt: new Date(),
    },
    { transaction: trx }
  );

  // 3. Create initial transaction record
  await db.walletTransactions.create(
    {
      transactionId: generateUUID(),
      walletId: wallet.walletId,
      memberId: input.memberId,
      transactionType: "Deposit",
      amount: input.initialBalance,
      balanceBefore: 0,
      balanceAfter: input.initialBalance,
      status: "Completed",
      sourceModule: "Membership",
      sourceTransactionType: "InitialDeposit",
      description: "Initial advance deposit from registration",
      createdAt: new Date(),
      createdBy: input.createdBy,
    },
    { transaction: trx }
  );

  return wallet;
}
```

**Note:** GL entry for initial deposit is created during member registration approval (not here).

---

#### 2. RequestWalletDeposit

**Triggered by:** Agent

**Input:**

```json
{
  "memberId": "uuid",
  "amount": 500,
  "collectionDate": "2025-01-15",
  "collectionMode": "Cash",
  "referenceNumber": "string?",
  "notes": "string?",
  "collectedBy": "uuid" // AgentId
}
```

**Preconditions:**

- Member exists and is active
- Member has a wallet
- Amount > 0
- Agent is assigned to this member
- collectionDate <= today

**Validations:**

- amount: required, > 0, max 2 decimal places
- collectionDate: required, cannot be in future
- collectionMode: required, valid enum
- If collectionMode = BankTransfer or Cheque, referenceNumber required

**Backend Logic:**

```javascript
async function requestWalletDeposit(input) {
  return await db.transaction(async (trx) => {
    // 1. Get member and wallet
    const member = await db.members.findByPk(input.memberId, {
      transaction: trx,
    });
    if (!member) {
      throw new Error("Member not found");
    }

    if (member.memberStatus !== "Active") {
      throw new Error("Member is not active");
    }

    const wallet = await db.memberWallets.findOne(
      {
        where: { memberId: input.memberId },
      },
      { transaction: trx }
    );

    if (!wallet) {
      throw new Error("Wallet not found for this member");
    }

    // 2. Validate agent
    const agent = await db.agents.findByPk(input.collectedBy, {
      transaction: trx,
    });
    if (!agent || agent.agentStatus !== "Active") {
      throw new Error("Agent not found or inactive");
    }

    if (agent.agentId !== member.agentId) {
      throw new Error("Agent is not assigned to this member");
    }

    // 3. Validate amount
    if (input.amount <= 0) {
      throw new Error("Amount must be positive");
    }

    // 4. Validate collection mode requirements
    if (
      ["BankTransfer", "Cheque"].includes(input.collectionMode) &&
      !input.referenceNumber
    ) {
      throw new Error("Reference number required for bank transfer/cheque");
    }

    // 5. Create deposit request
    const depositRequest = await db.walletDepositRequests.create(
      {
        depositRequestId: generateUUID(),
        memberId: input.memberId,
        walletId: wallet.walletId,
        amount: input.amount,
        collectionDate: input.collectionDate,
        collectionMode: input.collectionMode,
        referenceNumber: input.referenceNumber,
        collectedBy: input.collectedBy,
        status: "PendingApproval",
        notes: input.notes,
        createdAt: new Date(),
      },
      { transaction: trx }
    );

    // 6. Emit event
    await emitEvent("WalletDepositRequested", {
      depositRequestId: depositRequest.depositRequestId,
      memberId: input.memberId,
      amount: input.amount,
      collectedBy: input.collectedBy,
    });

    return depositRequest;
  });
}
```

**Outcome:**

- Deposit request created with status "PendingApproval"
- Event: `WalletDepositRequested`

---

#### 3. ApproveWalletDeposit

**Triggered by:** Unit Admin (or configured approver)

**Input:**

```json
{
  "depositRequestId": "uuid",
  "approvedBy": "uuid"
}
```

**Preconditions:**

- Deposit request exists with status "PendingApproval"
- User has permission to approve wallet deposits

**Backend Logic:**

```javascript
async function approveWalletDeposit(input) {
  return await db.transaction(async (trx) => {
    // 1. Get deposit request
    const depositRequest = await db.walletDepositRequests.findByPk(
      input.depositRequestId,
      { transaction: trx }
    );

    if (!depositRequest) {
      throw new Error("Deposit request not found");
    }

    if (depositRequest.status !== "PendingApproval") {
      throw new Error("Deposit request is not pending approval");
    }

    // 2. Check permission
    const member = await db.members.findByPk(depositRequest.memberId);
    const canApprove = await hasPermission(
      input.approvedBy,
      "wallet.deposit.approve",
      { unitId: member.unitId }
    );

    if (!canApprove) {
      throw new Error("Not authorized to approve deposits");
    }

    // 3. Get wallet
    const wallet = await db.memberWallets.findByPk(depositRequest.walletId, {
      transaction: trx,
    });

    // 4. Create wallet transaction
    const transaction = await db.walletTransactions.create(
      {
        transactionId: generateUUID(),
        walletId: wallet.walletId,
        memberId: depositRequest.memberId,
        transactionType: "Deposit",
        amount: depositRequest.amount,
        balanceBefore: wallet.currentBalance,
        balanceAfter: wallet.currentBalance + depositRequest.amount,
        status: "Completed",
        sourceModule: "Wallet",
        sourceEntityId: depositRequest.depositRequestId,
        sourceTransactionType: "WalletDepositApproval",
        description: `Deposit via ${depositRequest.collectionMode}`,
        approvedBy: input.approvedBy,
        approvedAt: new Date(),
        createdAt: new Date(),
        createdBy: input.approvedBy,
      },
      { transaction: trx }
    );

    // 5. Update wallet balance
    await db.memberWallets.update(
      {
        currentBalance: wallet.currentBalance + depositRequest.amount,
        totalDeposited: wallet.totalDeposited + depositRequest.amount,
        updatedAt: new Date(),
      },
      {
        where: { walletId: wallet.walletId },
      },
      { transaction: trx }
    );

    // 6. Create GL entry
    const journalEntry = await glService.createJournalEntry(
      {
        entries: [
          {
            accountCode: "1000", // Cash
            debit: depositRequest.amount,
            description: "Cash collected for wallet deposit",
          },
          {
            accountCode: "2100", // Member Prepaid Wallet Liability
            credit: depositRequest.amount,
            description: "Member wallet balance increased",
          },
        ],
        reference: `Wallet Deposit - ${depositRequest.depositRequestId}`,
        transactionDate: depositRequest.collectionDate,
        sourceModule: "Wallet",
        sourceEntityId: depositRequest.depositRequestId,
        sourceTransactionType: "WalletDepositApproval",
        createdBy: input.approvedBy,
      },
      trx
    );

    // 7. Update deposit request
    await db.walletDepositRequests.update(
      {
        status: "Approved",
        approvedBy: input.approvedBy,
        approvedAt: new Date(),
        walletTransactionId: transaction.transactionId,
        journalEntryId: journalEntry.entryId,
      },
      {
        where: { depositRequestId: input.depositRequestId },
      },
      { transaction: trx }
    );

    // 8. Link journal entry to transaction
    await db.walletTransactions.update(
      {
        journalEntryId: journalEntry.entryId,
      },
      {
        where: { transactionId: transaction.transactionId },
      },
      { transaction: trx }
    );

    // 9. Emit event
    await emitEvent("WalletDepositApproved", {
      depositRequestId: input.depositRequestId,
      memberId: depositRequest.memberId,
      amount: depositRequest.amount,
      newBalance: wallet.currentBalance + depositRequest.amount,
      approvedBy: input.approvedBy,
    });

    return {
      depositRequest,
      transaction,
      journalEntry,
    };
  });
}
```

**Outcome:**

- Deposit request status → "Approved"
- Wallet balance increased
- Wallet transaction created
- GL entry created (Dr. Cash, Cr. Member Wallet Liability)
- Event: `WalletDepositApproved`

---

#### 4. RejectWalletDeposit

**Triggered by:** Unit Admin (or configured approver)

**Input:**

```json
{
  "depositRequestId": "uuid",
  "rejectionReason": "string",
  "rejectedBy": "uuid"
}
```

**Backend Logic:**

```javascript
async function rejectWalletDeposit(input) {
  return await db.transaction(async (trx) => {
    // 1. Get deposit request
    const depositRequest = await db.walletDepositRequests.findByPk(
      input.depositRequestId,
      { transaction: trx }
    );

    if (!depositRequest) {
      throw new Error("Deposit request not found");
    }

    if (depositRequest.status !== "PendingApproval") {
      throw new Error("Deposit request is not pending approval");
    }

    // 2. Check permission
    const member = await db.members.findByPk(depositRequest.memberId);
    const canReject = await hasPermission(
      input.rejectedBy,
      "wallet.deposit.approve", // Same permission for approve/reject
      { unitId: member.unitId }
    );

    if (!canReject) {
      throw new Error("Not authorized to reject deposits");
    }

    // 3. Update deposit request
    await db.walletDepositRequests.update(
      {
        status: "Rejected",
        rejectionReason: input.rejectionReason,
        approvedBy: input.rejectedBy,
        approvedAt: new Date(),
      },
      {
        where: { depositRequestId: input.depositRequestId },
      },
      { transaction: trx }
    );

    // 4. Emit event
    await emitEvent("WalletDepositRejected", {
      depositRequestId: input.depositRequestId,
      memberId: depositRequest.memberId,
      amount: depositRequest.amount,
      reason: input.rejectionReason,
      rejectedBy: input.rejectedBy,
    });

    return depositRequest;
  });
}
```

**Outcome:**

- Deposit request status → "Rejected"
- No wallet or GL changes
- Agent must return cash to member (physical process)
- Event: `WalletDepositRejected`

---

#### 5. CreateWalletDebitRequest (System-triggered)

**Triggered by:** System (when contribution cycle starts)

**Input:**

```json
{
  "memberId": "uuid",
  "amount": 100,
  "reason": "Contribution for death claim CL-001",
  "contributionCycleId": "uuid",
  "memberContributionId": "uuid"
}
```

**Backend Logic:**

```javascript
async function createWalletDebitRequest(input, trx) {
  // 1. Get wallet
  const wallet = await db.memberWallets.findOne(
    {
      where: { memberId: input.memberId },
    },
    { transaction: trx }
  );

  if (!wallet) {
    throw new Error("Wallet not found");
  }

  // 2. Check if sufficient balance
  if (wallet.currentBalance < input.amount) {
    // Cannot create debit request - insufficient balance
    return null;
  }

  // 3. Create debit request
  const debitRequest = await db.walletDebitRequests.create(
    {
      debitRequestId: generateUUID(),
      memberId: input.memberId,
      walletId: wallet.walletId,
      amount: input.amount,
      reason: input.reason,
      contributionCycleId: input.contributionCycleId,
      memberContributionId: input.memberContributionId,
      status: "PendingAcknowledgment",
      createdAt: new Date(),
    },
    { transaction: trx }
  );

  // 4. Emit event (for notification)
  await emitEvent("WalletDebitRequestCreated", {
    debitRequestId: debitRequest.debitRequestId,
    memberId: input.memberId,
    amount: input.amount,
    contributionCycleId: input.contributionCycleId,
  });

  return debitRequest;
}
```

**Outcome:**

- Debit request created with status "PendingAcknowledgment"
- Agent notified to visit member for acknowledgment
- Event: `WalletDebitRequestCreated`

---

#### 6. AcknowledgeWalletDebit

**Triggered by:** Agent (after getting member's confirmation)

**Input:**

```json
{
  "debitRequestId": "uuid",
  "acknowledgedBy": "uuid" // AgentId
}
```

**Preconditions:**

- Debit request exists with status "PendingAcknowledgment"
- Agent is assigned to this member
- Wallet has sufficient balance

**Backend Logic:**

```javascript
async function acknowledgeWalletDebit(input) {
  return await db.transaction(async (trx) => {
    // 1. Get debit request
    const debitRequest = await db.walletDebitRequests.findByPk(
      input.debitRequestId,
      { transaction: trx }
    );

    if (!debitRequest) {
      throw new Error("Debit request not found");
    }

    if (debitRequest.status !== "PendingAcknowledgment") {
      throw new Error("Debit request is not pending acknowledgment");
    }

    // 2. Validate agent
    const member = await db.members.findByPk(debitRequest.memberId);
    const agent = await db.agents.findByPk(input.acknowledgedBy);

    if (!agent || agent.agentId !== member.agentId) {
      throw new Error("Agent is not assigned to this member");
    }

    // 3. Get wallet
    const wallet = await db.memberWallets.findByPk(debitRequest.walletId, {
      transaction: trx,
    });

    // 4. Check sufficient balance
    if (wallet.currentBalance < debitRequest.amount) {
      throw new Error("Insufficient wallet balance");
    }

    // 5. Create wallet transaction
    const transaction = await db.walletTransactions.create(
      {
        transactionId: generateUUID(),
        walletId: wallet.walletId,
        memberId: debitRequest.memberId,
        transactionType: "Debit",
        amount: debitRequest.amount,
        balanceBefore: wallet.currentBalance,
        balanceAfter: wallet.currentBalance - debitRequest.amount,
        status: "Completed",
        sourceModule: "Contributions",
        sourceEntityId: debitRequest.debitRequestId,
        sourceTransactionType: "ContributionDebitAcknowledged",
        description: debitRequest.reason,
        createdAt: new Date(),
        createdBy: input.acknowledgedBy,
      },
      { transaction: trx }
    );

    // 6. Update wallet balance
    await db.memberWallets.update(
      {
        currentBalance: wallet.currentBalance - debitRequest.amount,
        totalDebited: wallet.totalDebited + debitRequest.amount,
        updatedAt: new Date(),
      },
      {
        where: { walletId: wallet.walletId },
      },
      { transaction: trx }
    );

    // 7. Create GL entry
    const journalEntry = await glService.createJournalEntry(
      {
        entries: [
          {
            accountCode: "2100", // Member Prepaid Wallet Liability
            debit: debitRequest.amount,
            description: "Member wallet debited for contribution",
          },
          {
            accountCode: "4200", // Member Contribution Income
            credit: debitRequest.amount,
            description: "Contribution collected from wallet",
          },
        ],
        reference: `Contribution from Wallet - ${debitRequest.memberContributionId}`,
        transactionDate: new Date(),
        sourceModule: "Contributions",
        sourceEntityId: debitRequest.memberContributionId,
        sourceTransactionType: "ContributionFromWallet",
        createdBy: input.acknowledgedBy,
      },
      trx
    );

    // 8. Update debit request
    await db.walletDebitRequests.update(
      {
        status: "Completed",
        acknowledgedBy: input.acknowledgedBy,
        acknowledgedAt: new Date(),
        walletTransactionId: transaction.transactionId,
        journalEntryId: journalEntry.entryId,
      },
      {
        where: { debitRequestId: input.debitRequestId },
      },
      { transaction: trx }
    );

    // 9. Link journal entry to transaction
    await db.walletTransactions.update(
      {
        journalEntryId: journalEntry.entryId,
      },
      {
        where: { transactionId: transaction.transactionId },
      },
      { transaction: trx }
    );

    // 10. Emit event
    await emitEvent("WalletDebitAcknowledged", {
      debitRequestId: input.debitRequestId,
      memberId: debitRequest.memberId,
      amount: debitRequest.amount,
      contributionCycleId: debitRequest.contributionCycleId,
      memberContributionId: debitRequest.memberContributionId,
      newBalance: wallet.currentBalance - debitRequest.amount,
      acknowledgedBy: input.acknowledgedBy,
    });

    return {
      debitRequest,
      transaction,
      journalEntry,
    };
  });
}
```

**Outcome:**

- Debit request status → "Completed"
- Wallet balance decreased
- Wallet transaction created
- GL entry created (Dr. Member Wallet Liability, Cr. Contribution Income)
- Member contribution marked as collected (handled by event listener)
- Event: `WalletDebitAcknowledged`

---

#### 7. InvalidateWalletDebitRequest

**Triggered by:** Agent (when member pays directly in cash instead)

**Input:**

```json
{
  "debitRequestId": "uuid",
  "invalidatedReason": "Member paid directly in cash",
  "invalidatedBy": "uuid" // AgentId
}
```

**Backend Logic:**

```javascript
async function invalidateWalletDebitRequest(input) {
  return await db.transaction(async (trx) => {
    // 1. Get debit request
    const debitRequest = await db.walletDebitRequests.findByPk(
      input.debitRequestId,
      { transaction: trx }
    );

    if (!debitRequest) {
      throw new Error("Debit request not found");
    }

    if (debitRequest.status !== "PendingAcknowledgment") {
      throw new Error("Can only invalidate pending debit requests");
    }

    // 2. Validate agent
    const member = await db.members.findByPk(debitRequest.memberId);
    const agent = await db.agents.findByPk(input.invalidatedBy);

    if (!agent || agent.agentId !== member.agentId) {
      throw new Error("Agent is not assigned to this member");
    }

    // 3. Update debit request
    await db.walletDebitRequests.update(
      {
        status: "Invalidated",
        invalidatedReason: input.invalidatedReason,
        invalidatedBy: input.invalidatedBy,
        invalidatedAt: new Date(),
      },
      {
        where: { debitRequestId: input.debitRequestId },
      },
      { transaction: trx }
    );

    // 4. Emit event
    await emitEvent("WalletDebitRequestInvalidated", {
      debitRequestId: input.debitRequestId,
      memberId: debitRequest.memberId,
      contributionCycleId: debitRequest.contributionCycleId,
      memberContributionId: debitRequest.memberContributionId,
      invalidatedBy: input.invalidatedBy,
    });

    return debitRequest;
  });
}
```

**Outcome:**

- Debit request status → "Invalidated"
- No wallet or GL changes
- Member contribution will be marked as "DirectPayment" (handled separately)
- Event: `WalletDebitRequestInvalidated`

---

#### 8. GetWalletBalance

**Input:**

```json
{
  "memberId": "uuid",
  "requestedBy": "uuid"
}
```

**Backend Logic:**

```javascript
async function getWalletBalance(memberId, requestedBy) {
  // 1. Get member
  const member = await db.members.findByPk(memberId);
  if (!member) {
    throw new Error("Member not found");
  }

  // 2. Check permission
  const canView =
    requestedBy === member.userId ||
    (await hasPermission(requestedBy, "wallet.balance.view", {
      unitId: member.unitId,
    }));

  if (!canView) {
    throw new Error("Not authorized to view wallet balance");
  }

  // 3. Get wallet
  const wallet = await db.memberWallets.findOne({
    where: { memberId },
  });

  if (!wallet) {
    throw new Error("Wallet not found");
  }

  // 4. Get pending debit requests
  const pendingDebits =
    (await db.walletDebitRequests.sum("amount", {
      where: {
        memberId,
        status: "PendingAcknowledgment",
      },
    })) || 0;

  return {
    walletId: wallet.walletId,
    currentBalance: wallet.currentBalance,
    availableBalance: wallet.currentBalance - pendingDebits,
    pendingDebits,
    totalDeposited: wallet.totalDeposited,
    totalDebited: wallet.totalDebited,
  };
}
```

---

#### 9. GetWalletTransactionHistory

**Input:**

```json
{
  "memberId": "uuid",
  "page": 1,
  "limit": 20,
  "transactionType": "Deposit|Debit?",
  "requestedBy": "uuid"
}
```

**Backend Logic:**

```javascript
async function getWalletTransactionHistory(filters) {
  // 1. Check permission
  const member = await db.members.findByPk(filters.memberId);
  const canView =
    filters.requestedBy === member.userId ||
    (await hasPermission(filters.requestedBy, "wallet.balance.view", {
      unitId: member.unitId,
    }));

  if (!canView) {
    throw new Error("Not authorized");
  }

  // 2. Build query
  const where = {
    memberId: filters.memberId,
    status: "Completed",
  };

  if (filters.transactionType) {
    where.transactionType = filters.transactionType;
  }

  const offset = (filters.page - 1) * filters.limit;

  // 3. Fetch transactions
  const { count, rows } = await db.walletTransactions.findAndCountAll({
    where,
    order: [["createdAt", "DESC"]],
    limit: filters.limit,
    offset,
  });

  return {
    total: count,
    page: filters.page,
    limit: filters.limit,
    transactions: rows.map((tx) => ({
      transactionId: tx.transactionId,
      transactionType: tx.transactionType,
      amount: tx.amount,
      balanceBefore: tx.balanceBefore,
      balanceAfter: tx.balanceAfter,
      description: tx.description,
      createdAt: tx.createdAt,
    })),
  };
}
```

---

#### 10. ReconcileWalletBalance

**Triggered by:** System (daily reconciliation job) or Admin

**Input:**

```json
{
  "asOfDate": "2025-01-15"
}
```

**Backend Logic:**

```javascript
async function reconcileWalletBalance(asOfDate) {
  // 1. Sum all member wallet balances (sub-ledger)
  const totalWalletBalances = await db.memberWallets.sum("currentBalance");
  // 2. Get GL account balance for Member Wallet Liability
  const glBalance = await glService.getAccountBalance("2100", asOfDate);
  // 3. Compare
  const difference = totalWalletBalances - glBalance.balance;
  // 4. If difference, log alert
  if (Math.abs(difference) > 0.01) {
    console.error("RECONCILIATION FAILED:", {
      asOfDate,
      totalWalletBalances,
      glBalance: glBalance.balance,
      difference,
    });
    // Create alert for admins
    await createSystemAlert({
      type: "ReconciliationFailure",
      severity: "High",
      message: `Wallet reconciliation failed. Difference: ${difference}`,
      data: { totalWalletBalances, glBalance: glBalance.balance, difference },
    });
  }
  return {
    asOfDate,
    totalWalletBalances,
    glBalance: glBalance.balance,
    difference,
    reconciled: Math.abs(difference) < 0.01,
  };
}
```

---

## Database Schema

```sql
CREATE TABLE member_wallets (
  wallet_id UUID PRIMARY KEY,
  member_id UUID UNIQUE NOT NULL REFERENCES members(member_id),
  current_balance DECIMAL(15,2) DEFAULT 0 CHECK (current_balance >= 0),
  total_deposited DECIMAL(15,2) DEFAULT 0,
  total_debited DECIMAL(15,2) DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE wallet_transactions (
  transaction_id UUID PRIMARY KEY,
  wallet_id UUID NOT NULL REFERENCES member_wallets(wallet_id),
  member_id UUID NOT NULL REFERENCES members(member_id),
  transaction_type VARCHAR(20) NOT NULL, -- Deposit, Debit, Refund, Adjustment
  amount DECIMAL(15,2) NOT NULL CHECK (amount > 0),
  balance_before DECIMAL(15,2) NOT NULL,
  balance_after DECIMAL(15,2) NOT NULL,
  status VARCHAR(20) NOT NULL, -- Pending, Approved, Rejected, Completed, Cancelled
  source_module VARCHAR(50),
  source_entity_id UUID,
  source_transaction_type VARCHAR(100),
  journal_entry_id UUID REFERENCES journal_entries(entry_id),
  description TEXT,
  notes TEXT,
  approved_by UUID REFERENCES users(user_id),
  approved_at TIMESTAMP,
  rejection_reason TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  created_by UUID REFERENCES users(user_id)
);

CREATE TABLE wallet_deposit_requests (
  deposit_request_id UUID PRIMARY KEY,
  member_id UUID NOT NULL REFERENCES members(member_id),
  wallet_id UUID NOT NULL REFERENCES member_wallets(wallet_id),
  amount DECIMAL(15,2) NOT NULL CHECK (amount > 0),
  collection_date DATE NOT NULL,
  collection_mode VARCHAR(20) NOT NULL, -- Cash, BankTransfer, Cheque
  reference_number VARCHAR(100),
  collected_by UUID NOT NULL REFERENCES agents(agent_id),
  status VARCHAR(20) DEFAULT 'PendingApproval', -- PendingApproval, Approved, Rejected
  approved_by UUID REFERENCES users(user_id),
  approved_at TIMESTAMP,
  rejection_reason TEXT,
  wallet_transaction_id UUID REFERENCES wallet_transactions(transaction_id),
  journal_entry_id UUID REFERENCES journal_entries(entry_id),
  notes TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE wallet_debit_requests (
  debit_request_id UUID PRIMARY KEY,
  member_id UUID NOT NULL REFERENCES members(member_id),
  wallet_id UUID NOT NULL REFERENCES member_wallets(wallet_id),
  amount DECIMAL(15,2) NOT NULL CHECK (amount > 0),
  reason TEXT NOT NULL,
  contribution_cycle_id UUID NOT NULL,
  member_contribution_id UUID NOT NULL,
  status VARCHAR(30) DEFAULT 'PendingAcknowledgment', -- PendingAcknowledgment, Acknowledged, Completed, Invalidated, Cancelled
  acknowledged_by UUID REFERENCES agents(agent_id),
  acknowledged_at TIMESTAMP,
  wallet_transaction_id UUID REFERENCES wallet_transactions(transaction_id),
  journal_entry_id UUID REFERENCES journal_entries(entry_id),
  invalidated_reason TEXT,
  invalidated_by UUID REFERENCES agents(agent_id),
  invalidated_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_wallets_member ON member_wallets(member_id);
CREATE INDEX idx_wallet_txns_wallet ON wallet_transactions(wallet_id);
CREATE INDEX idx_wallet_txns_member ON wallet_transactions(member_id);
CREATE INDEX idx_wallet_txns_type ON wallet_transactions(transaction_type, status);
CREATE INDEX idx_wallet_txns_source ON wallet_transactions(source_module, source_entity_id);
CREATE INDEX idx_deposit_req_member ON wallet_deposit_requests(member_id);
CREATE INDEX idx_deposit_req_status ON wallet_deposit_requests(status);
CREATE INDEX idx_debit_req_member ON wallet_debit_requests(member_id);
CREATE INDEX idx_debit_req_status ON wallet_debit_requests(status);
CREATE INDEX idx_debit_req_contribution ON wallet_debit_requests(member_contribution_id);
```

---

## Validation Rules Summary

### Deposits

- Amount must be > 0
- Collection date cannot be in future
- Agent must be assigned to member
- Reference number required for BankTransfer/Cheque

### Debits

- Amount must be > 0
- Wallet balance must be sufficient
- Only pending debit requests can be acknowledged or invalidated
- Agent must be assigned to member

### Balance

- Balance cannot go negative
- Balance = sum of all completed transactions
- Must reconcile with GL account 2100

---

## Events Emitted

- `WalletDepositRequested` - When agent creates deposit request
- `WalletDepositApproved` - When admin approves deposit
- `WalletDepositRejected` - When admin rejects deposit
- `WalletDebitRequestCreated` - When system creates debit request
- `WalletDebitAcknowledged` - When agent acknowledges debit
- `WalletDebitRequestInvalidated` - When debit request cancelled (direct payment)

---

## Summary: Commands List

1. `CreateMemberWallet` (System, on registration approval)
2. `RequestWalletDeposit` (Agent)
3. `ApproveWalletDeposit` (Unit Admin)
4. `RejectWalletDeposit` (Unit Admin)
5. `CreateWalletDebitRequest` (System, on contribution cycle start)
6. `AcknowledgeWalletDebit` (Agent)
7. `InvalidateWalletDebitRequest` (Agent)
8. `GetWalletBalance` (Member, Agent, Admins)
9. `GetWalletTransactionHistory` (Member, Agent, Admins)
10. `ReconcileWalletBalance` (System/Admin)

---

**Member Wallet context is complete!**

This design ensures:

- Every wallet transaction has corresponding GL entry (atomic)
- Balance cannot go negative
- Approval workflows for deposits
- Acknowledgment required for debits
- Reconciliation with GL
- Complete audit trail
